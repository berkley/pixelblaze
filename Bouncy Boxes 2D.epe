{
  "name": "Bouncy Boxes 2D",
  "id": "JQd3rFSF9waCn843M",
  "sources": {
    "main": "/*\n  4 smooth 4x4 squares with impulse collisions (no slowdown)\n  - X wraps (cylinder 32)\n  - Y bounces (height 8)\n  - Squares collide and bounce, no intersections\n  - Rainbow base hue per square + radial hue from center outward\n  - Deterministic index mapping (matches your mapper)\n  - Background glitches:\n      * random sparkles\n      * occasional short horizontal streaks\n      * NEW: \"digital tearing\" bands (random rows shifted in X for a moment)\n*/\n\nW = 8\nA = 32\nS = 4\nmaxH = W - S\n\n// ----- initial conditions -----\nax0 =  2.0; hy0 = 1.0; vx0 =  4.2; vy0 =  2.1\nax1 = 10.0; hy1 = 3.0; vx1 = -3.6; vy1 =  1.8\nax2 = 18.0; hy2 = 0.5; vx2 =  3.0; vy2 = -2.4\nax3 = 26.0; hy3 = 2.0; vx3 = -4.8; vy3 = -1.6\n\n// physics knobs\nrestitution = 1.0\nposSlop = 0.01\nposPercent = 0.70\nsolverIters = 6\ntargetSpeed = 5.0\n\n// hues (animated in beforeRender)\nh0 = 0; h1 = 0.25; h2 = 0.5; h3 = 0.75\n\n// background glitch controls\nvar glitchRate = 0.00          // sparkle chance per pixel per glitch frame\nvar glitchVal  = 0.00           // sparkle brightness\nvar glitchSat  = 1.0\n\nexport function sliderGlitchRate(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  glitchRate = v;\n}\nexport function sliderGlitchBrightness(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  glitchVal = v;\n}\nexport function sliderGlitchSat(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  glitchSat = v;\n}\n\n// tearing controls\nvar tearChance = 0.06       // chance each tear band is active per tear frame (0..1)\nvar tearFramesPerSec = 10    // how often tear config changes\nvar tearMaxShift = 10         // max pixel shift in X for tearing\nvar tearVal = 0.5          // brightness for tear pixels\nvar tearSat = .05 \n\nexport function sliderTearChance(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  tearChance = v;\n}\nexport function sliderTearFramesPerSec(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  tearFramesPerSec = v * 10;\n}\nexport function sliderTearBrightness(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  tearVal = v;\n}\nexport function sliderTearSat(v) {\n  // v is automatically passed as a value between 0.0 and 1.0\n  tearSat = v;\n}\n\nfunction wrap01(v) { return v - floor(v) }\nfunction wrapA(v) { return (v % A + A) % A }\n\nfunction wrapDxSigned(a, b) {\n  d = a - b\n  if (d >  A * 0.5) d -= A\n  if (d < -A * 0.5) d += A\n  return d\n}\n\nfunction clampYAndBounce(i) {\n  if (i == 0) {\n    if (hy0 < 0)    { hy0 = -hy0;         vy0 = -vy0 }\n    if (hy0 > maxH) { hy0 = 2*maxH-hy0;   vy0 = -vy0 }\n  } else if (i == 1) {\n    if (hy1 < 0)    { hy1 = -hy1;         vy1 = -vy1 }\n    if (hy1 > maxH) { hy1 = 2*maxH-hy1;   vy1 = -vy1 }\n  } else if (i == 2) {\n    if (hy2 < 0)    { hy2 = -hy2;         vy2 = -vy2 }\n    if (hy2 > maxH) { hy2 = 2*maxH-hy2;   vy2 = -vy2 }\n  } else {\n    if (hy3 < 0)    { hy3 = -hy3;         vy3 = -vy3 }\n    if (hy3 > maxH) { hy3 = 2*maxH-hy3;   vy3 = -vy3 }\n  }\n}\n\nfunction get(i) {\n  if (i == 0) { ax=ax0; hy=hy0; vx=vx0; vy=vy0 }\n  else if (i == 1) { ax=ax1; hy=hy1; vx=vx1; vy=vy1 }\n  else if (i == 2) { ax=ax2; hy=hy2; vx=vx2; vy=vy2 }\n  else { ax=ax3; hy=hy3; vx=vx3; vy=vy3 }\n}\n\nfunction set(i, ax, hy, vx, vy) {\n  if (i == 0) { ax0=ax; hy0=hy; vx0=vx; vy0=vy }\n  else if (i == 1) { ax1=ax; hy1=hy; vx1=vx; vy1=vy }\n  else if (i == 2) { ax2=ax; hy2=hy; vx2=vx; vy2=vy }\n  else { ax3=ax; hy3=hy; vx3=vx; vy3=vy }\n}\n\nfunction keepSpeed(i, target) {\n  get(i)\n  sp = sqrt(vx*vx + vy*vy)\n  if (sp > 0.0001) {\n    s = target / sp\n    set(i, ax, hy, vx * s, vy * s)\n  }\n}\n\nfunction collide(i, j) {\n  get(i); axi=ax; hyi=hy; vxi=vx; vyi=vy\n  get(j); axj=ax; hyj=hy; vxj=vx; vyj=vy\n\n  cxi = axi + S*0.5\n  cyi = hyi + S*0.5\n  cxj = axj + S*0.5\n  cyj = hyj + S*0.5\n\n  dx = wrapDxSigned(cxi, cxj)\n  dy = cyi - cyj\n  adx = abs(dx)\n  ady = abs(dy)\n\n  if (adx < S && ady < S) {\n    px = S - adx\n    py = S - ady\n\n    if (px < py) { nx = (dx >= 0) ? 1 : -1; ny = 0; pen = px }\n    else         { nx = 0; ny = (dy >= 0) ? 1 : -1; pen = py }\n\n    corr = posPercent * max(pen - posSlop, 0) * 0.5\n    axi += nx * corr; hyi += ny * corr\n    axj -= nx * corr; hyj -= ny * corr\n\n    axi = wrapA(axi); axj = wrapA(axj)\n\n    set(i, axi, hyi, vxi, vyi); clampYAndBounce(i); get(i); axi=ax; hyi=hy; vxi=vx; vyi=vy\n    set(j, axj, hyj, vxj, vyj); clampYAndBounce(j); get(j); axj=ax; hyj=hy; vxj=vx; vyj=vy\n\n    rvx = vxi - vxj\n    rvy = vyi - vyj\n    velN = rvx*nx + rvy*ny\n\n    if (velN < 0) {\n      jImp = -(1 + restitution) * velN / 2\n      ix = jImp * nx\n      iy = jImp * ny\n      vxi += ix; vyi += iy\n      vxj -= ix; vyj -= iy\n    }\n\n    set(i, axi, hyi, vxi, vyi)\n    set(j, axj, hyj, vxj, vyj)\n  }\n}\n\nfunction softBox(px, py, ax, hy) {\n  dx = wrapDxSigned(px, ax)\n  pxx = ax + dx\n\n  left   = pxx - ax\n  right  = (ax + S) - pxx\n  top    = py - hy\n  bottom = (hy + S) - py\n\n  d = min(min(left, right), min(top, bottom))\n  soft = 0.8\n  return clamp((d + soft) / soft, 0, 1)\n}\n\nfunction radialHue(px, py, ax, hy, baseHue) {\n  dxw = wrapDxSigned(px, ax)\n  pxx = ax + dxw\n\n  cx = ax + S*0.5\n  cy = hy + S*0.5\n\n  dx = pxx - cx\n  dy = py - cy\n\n  rMax = (S * 0.5) * 1.4142\n  dist = sqrt(dx*dx + dy*dy) / rMax\n  dist = clamp(dist, 0, 1)\n\n  return wrap01(baseHue + dist * 0.60)\n}\n\n// stable pseudo-random 0..1\nfunction hash01(n) {\n  return wrap01(sin(n * 12.9898 + 78.233) * 43758.5453)\n}\n\n// ----- tearing state (computed in beforeRender) -----\ntearRow0 = 0; tearRow1 = 0; tearRow2 = 0\ntearShift0 = 0; tearShift1 = 0; tearShift2 = 0\ntearOn0 = 0; tearOn1 = 0; tearOn2 = 0\ntearHue0 = 0; tearHue1 = 0; tearHue2 = 0\ngFrame = 0\n\nexport function beforeRender(delta) {\n  dt = min(delta / 1000, 0.05)\n\n  // integrate\n  ax0 = wrapA(ax0 + vx0 * dt); hy0 += vy0 * dt\n  ax1 = wrapA(ax1 + vx1 * dt); hy1 += vy1 * dt\n  ax2 = wrapA(ax2 + vx2 * dt); hy2 += vy2 * dt\n  ax3 = wrapA(ax3 + vx3 * dt); hy3 += vy3 * dt\n\n  clampYAndBounce(0)\n  clampYAndBounce(1)\n  clampYAndBounce(2)\n  clampYAndBounce(3)\n\n  // collisions\n  for (k = 0; k < solverIters; k++) {\n    collide(0,1); collide(0,2); collide(0,3)\n    collide(1,2); collide(1,3)\n    collide(2,3)\n  }\n\n  keepSpeed(0, targetSpeed)\n  keepSpeed(1, targetSpeed)\n  keepSpeed(2, targetSpeed)\n  keepSpeed(3, targetSpeed)\n\n  // rainbow base hues per square\n  t = time(12 / 65.536)\n  h0 = wrap01(t + 0.00)\n  h1 = wrap01(t + 0.25)\n  h2 = wrap01(t + 0.50)\n  h3 = wrap01(t + 0.75)\n\n  // glitch frame counters\n  gFrame = floor(time(18 / 65.536) * 1000)\n\n  // tearing \"frame\" (changes a few times per second)\n  tearFrame = floor(time((1 / tearFramesPerSec) / 65.536) * 100000)\n\n  // pick up to 3 tear bands (random rows), each with its own shift\n  // each band sometimes off\n  r0 = hash01(tearFrame * 31.0 + 1.0)\n  r1 = hash01(tearFrame * 37.0 + 2.0)\n  r2 = hash01(tearFrame * 41.0 + 3.0)\n\n  tearRow0 = floor(hash01(tearFrame * 53.0 + 4.0) * W)\n  tearRow1 = floor(hash01(tearFrame * 59.0 + 5.0) * W)\n  tearRow2 = floor(hash01(tearFrame * 61.0 + 6.0) * W)\n\n  // shifts in [-tearMaxShift, +tearMaxShift]\n  tearShift0 = floor((hash01(tearFrame * 67.0 + 7.0) * 2 - 1) * tearMaxShift)\n  tearShift1 = floor((hash01(tearFrame * 71.0 + 8.0) * 2 - 1) * tearMaxShift)\n  tearShift2 = floor((hash01(tearFrame * 73.0 + 9.0) * 2 - 1) * tearMaxShift)\n\n  tearOn0 = (r0 < tearChance) ? 1 : 0\n  tearOn1 = (r1 < tearChance) ? 1 : 0\n  tearOn2 = (r2 < tearChance) ? 1 : 0\n\n  tearHue0 = hash01(tearFrame * 79.0 + 10.0)\n  tearHue1 = hash01(tearFrame * 83.0 + 11.0)\n  tearHue2 = hash01(tearFrame * 89.0 + 12.0)\n}\n\nexport function render2D(index, x, y) {\n  // exact mapper-derived coords\n  around = floor(index / W)   // 0..31\n  h = index % W               // 0..7\n  if (around % 2 == 1) h = (W - 1) - h\n\n  // ---- digital tearing: shift some rows in X (background only + affects square sampling) ----\n  // We'll apply tearing to the \"pixel sample position\" px, but NOT to the physical mapping.\n  // This creates a tearing illusion without changing your actual topology.\n  pxBase = around + 0.5\n  py = h + 0.5\n\n  tearShift = 0\n  tearHue = 0\n  tearOn = 0\n\n  if (tearOn0 && h == tearRow0) { tearShift = tearShift0; tearHue = tearHue0; tearOn = 1 }\n  if (tearOn1 && h == tearRow1) { tearShift = tearShift1; tearHue = tearHue1; tearOn = 1 }\n  if (tearOn2 && h == tearRow2) { tearShift = tearShift2; tearHue = tearHue2; tearOn = 1 }\n\n  // apply shift with wrap for sampling\n  px = wrapA(pxBase + tearShift)\n\n  // squares sampled at torn px (so the whole scene appears torn)\n  v0 = softBox(px, py, ax0, hy0)\n  v1 = softBox(px, py, ax1, hy1)\n  v2 = softBox(px, py, ax2, hy2)\n  v3 = softBox(px, py, ax3, hy3)\n\n  total = v0 + v1 + v2 + v3\n\n  // ---- background glitches (only visible where squares aren't) ----\n  r = hash01(index + gFrame * 97.0)\n  sparkle = (r < glitchRate) ? 1 : 0\n  gAmt = sparkle ? glitchVal : 0\n\n  // occasional short horizontal streak (rare)\n  rr = hash01(gFrame * 13.0 + 5.0)\n  rs = hash01(gFrame * 17.0 + 11.0)\n  rowPick = floor(rr * W)\n  streakCenter = floor(rs * A)\n  dxs = abs(wrapDxSigned(around, streakCenter))\n  streak = (h == rowPick && dxs <= 2) ? 1 : 0\n  if (streak) gAmt = max(gAmt, glitchVal * 0.7)\n\n  // tearing band brightness (background feel)\n  tearAmt = tearOn ? tearVal : 0\n\n  // ---- choose final pixel ----\n  if (total > 0) {\n    // dominant square hue, radiating outward\n    bestV = v0; hue = radialHue(px, py, ax0, hy0, h0)\n    if (v1 > bestV) { bestV = v1; hue = radialHue(px, py, ax1, hy1, h1) }\n    if (v2 > bestV) { bestV = v2; hue = radialHue(px, py, ax2, hy2, h2) }\n    if (v3 > bestV) { bestV = v3; hue = radialHue(px, py, ax3, hy3, h3) }\n\n    // subtle tear overlay on squares\n    val = clamp(total + tearAmt * 0.15, 0, 1)\n    hsv(hue, 1, val)\n  } else if (tearAmt > 0) {\n    // tearing-only band\n    hsv(tearHue, tearSat, tearAmt)\n  } else if (gAmt > 0) {\n    // sparkles/streaks\n    gHue = hash01(index * 3.0 + gFrame * 19.0)\n    hsv(gHue, glitchSat, gAmt)\n  } else {\n    hsv(0, 0, 0)\n  }\n}\n\nexport function render(index) {\n  hsv(0, 0, 0)\n}\n"
  },
  "preview": "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"
}