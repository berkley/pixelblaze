{
  "name": "Bouncing Box Trails 2D",
  "id": "ff6sXvJQHn9rDemeg",
  "sources": {
    "main": "/*\n  CYLINDER BOXES ENGINE (32 around x 8 tall, zigzag-wired height=8)\n  - Variable number of boxes (BOX_COUNT)\n  - Variable box sizes (SIZE_MIN..SIZE_MAX)\n  - Per-box mass (MASS_MIN..MASS_MAX) affects collisions\n  - Wrap in X (cylinder), bounce in Y\n  - Impulse-based collisions (no intersections), stable speed\n  - Rainbow base hue per box + radial hue from center outward\n  - Trails (per-pixel persistence) with TRAIL_DECAY\n  - Background glitches: sparkles + tearing bands\n  - “Explode into pixels” glitch events (particle bursts)\n\n  NOTE: This pattern deliberately ignores render2D(x,y) coords and uses index->(around,height)\n  to match your mapper’s zigzag wiring.\n*/\n\n/////////////////////\n// CORE CONFIG\n/////////////////////\n\n//matrix size - 32x8 array wrapped around a cylinder\nA            = 32         // around\nW            = 8          // tall\n\n//box variables\nBOX_COUNT    = 4             // number of boxes\nSIZE_MIN     = 1          // box size range (pixels)\nSIZE_MAX     = 3  \n\n// Motion / physics\nTARGET_SPEED = 5.0        // pixels/sec, enforced (prevents slowing)\nSOLVER_ITERS = 6          // collision solver passes\nRESTITUTION  = 0.98       // bounciness (1 = perfectly elastic)\nPOS_SLOP     = 0.01       // overlap allowed before correction\nPOS_PERCENT  = 0.75       // overlap correction strength (0..1)\n\n// Color / trails\nHUE_RATE_SEC = 12         // seconds per full hue cycle (bigger = slower)\nRADIAL_HUE_SPAN = 0.60    // how much hue shifts from center->edge\nTRAIL_DECAY  = 0.7         // 0..1 (higher = longer trails)\n\n// Background glitches\nGLITCH_RATE  = 0.0       // sparkle chance per pixel per glitch frame\nGLITCH_VAL   = 0.0       // sparkle brightness\n\nTEAR_CHANCE  = 0.00           // tearing band active chance per tear frame\nTEAR_MAX_SHIFT = 7        // max X shift during tearing\nTEAR_FPS     = 10         // tear config changes per second\nTEAR_VAL     = 0.0         // tearing band brightness\n\n// Explode glitch (particle bursts)\nEXPLODE_RATE = 0.15         // bursts per second (0.08 ~= one every ~12s avg)\nPARTICLE_COUNT = 20       // particles in a burst\nPARTICLE_TTL   = 0.75     // seconds\nPARTICLE_VAL   = 0.65     // max brightness\nPARTICLE_RADIUS = 2.5     // visual radius (pixels)\n\n// Per-box mass range\nMASS_MIN = 0.8\nMASS_MAX = 2.2\n\n/////////////////////\n// INTERNAL STATE\n/////////////////////\n\nPI2 = 6.283185307179586\n\n// boxes\nax = array(BOX_COUNT)   // top-left X (float, wraps)\nhy = array(BOX_COUNT)   // top-left Y (float, bounces)\nvx = array(BOX_COUNT)\nvy = array(BOX_COUNT)\nbs = array(BOX_COUNT)   // size in pixels (int)\nm  = array(BOX_COUNT)   // mass\ninvM = array(BOX_COUNT) // 1/mass\nbh = array(BOX_COUNT)   // base hue\n\n// trails (allocated once we know pixelCount)\ntrailV = 0\ntrailH = 0\n\n// particles\npxp = array(PARTICLE_COUNT)   // x\npyp = array(PARTICLE_COUNT)   // y\npvr = array(PARTICLE_COUNT)   // vx\npvt = array(PARTICLE_COUNT)   // vy\nptt = array(PARTICLE_COUNT)   // ttl remaining\nphu = array(PARTICLE_COUNT)   // hue\npActive = 0\n\n// tearing state\ntearRow0 = 0; tearRow1 = 0; tearRow2 = 0\ntearShift0 = 0; tearShift1 = 0; tearShift2 = 0\ntearOn0 = 0; tearOn1 = 0; tearOn2 = 0\ntearHue0 = 0; tearHue1 = 0; tearHue2 = 0\ngFrame = 0\n\n// init boxes once\ninited = 0\n\n/////////////////////\n// HELPERS\n/////////////////////\n\nfunction wrap01(v) { return v - floor(v) }\nfunction wrapA(v) { return (v % A + A) % A }\n\nfunction clamp01(v) { return clamp(v, 0, 1) }\n\n// signed shortest difference a-b on [0,A)\nfunction wrapDxSigned(a, b) {\n  d = a - b\n  if (d >  A * 0.5) d -= A\n  if (d < -A * 0.5) d += A\n  return d\n}\n\nfunction hash01(n) {\n  return wrap01(sin(n * 12.9898 + 78.233) * 43758.5453)\n}\n\nfunction randRange(a, b) { return a + (b - a) * random(1) }\n\nfunction keepSpeed(i) {\n  sp = sqrt(vx[i]*vx[i] + vy[i]*vy[i])\n  if (sp > 0.0001) {\n    s = TARGET_SPEED / sp\n    vx[i] *= s\n    vy[i] *= s\n  }\n}\n\nfunction clampY(i) {\n  maxH = W - bs[i]\n  if (hy[i] < 0)    { hy[i] = -hy[i];         vy[i] = -vy[i] * RESTITUTION }\n  if (hy[i] > maxH) { hy[i] = 2*maxH - hy[i]; vy[i] = -vy[i] * RESTITUTION }\n}\n\nfunction radialHue(px, py, i, baseHue) {\n  // px already potentially wrapped/shifted in X; align it near the box\n  dxw = wrapDxSigned(px, ax[i])\n  pxx = ax[i] + dxw\n\n  cx = ax[i] + bs[i]*0.5\n  cy = hy[i] + bs[i]*0.5\n\n  dx = pxx - cx\n  dy = py - cy\n\n  rMax = (bs[i] * 0.5) * 1.4142\n  dist = sqrt(dx*dx + dy*dy) / rMax\n  dist = clamp(dist, 0, 1)\n\n  return wrap01(baseHue + dist * RADIAL_HUE_SPAN)\n}\n\n// Soft filled box (anti-aliased edges), wrapped X\nfunction softBox(px, py, i) {\n  // align px near the box in wrapped space\n  dx = wrapDxSigned(px, ax[i])\n  pxx = ax[i] + dx\n\n  left   = pxx - ax[i]\n  right  = (ax[i] + bs[i]) - pxx\n  top    = py - hy[i]\n  bottom = (hy[i] + bs[i]) - py\n\n  d = min(min(left, right), min(top, bottom))\n  soft = 0.8\n  return clamp((d + soft) / soft, 0, 1)\n}\n\n// AABB collision with variable sizes, wrapped X, impulse + positional correction\nfunction collide(i, j) {\n  si = bs[i]; sj = bs[j]\n\n  cxi = ax[i] + si*0.5\n  cyi = hy[i] + si*0.5\n  cxj = ax[j] + sj*0.5\n  cyj = hy[j] + sj*0.5\n\n  dx = wrapDxSigned(cxi, cxj)\n  dy = cyi - cyj\n\n  adx = abs(dx)\n  ady = abs(dy)\n\n  // overlap thresholds are half-extents sum\n  hx = (si + sj) * 0.5\n  hySum = (si + sj) * 0.5\n\n  if (adx < hx && ady < hySum) {\n    px = hx - adx\n    py = hySum - ady\n\n    // collision normal = minimum penetration axis\n    if (px < py) { nx = (dx >= 0) ? 1 : -1; ny = 0; pen = px }\n    else         { nx = 0; ny = (dy >= 0) ? 1 : -1; pen = py }\n\n    // positional correction split by inverse mass\n    invSum = invM[i] + invM[j]\n    if (invSum < 0.0001) invSum = 1\n\n    corr = POS_PERCENT * max(pen - POS_SLOP, 0)\n    ci = corr * (invM[i] / invSum)\n    cj = corr * (invM[j] / invSum)\n\n    ax[i] += nx * ci\n    hy[i] += ny * ci\n    ax[j] -= nx * cj\n    hy[j] -= ny * cj\n\n    ax[i] = wrapA(ax[i])\n    ax[j] = wrapA(ax[j])\n    clampY(i)\n    clampY(j)\n\n    // relative velocity along normal\n    rvx = vx[i] - vx[j]\n    rvy = vy[i] - vy[j]\n    velN = rvx*nx + rvy*ny\n\n    // impulse (only if approaching)\n    if (velN < 0) {\n      jImp = -(1 + RESTITUTION) * velN / (invM[i] + invM[j])\n      ix = jImp * nx\n      iy = jImp * ny\n      vx[i] += ix * invM[i]\n      vy[i] += iy * invM[i]\n      vx[j] -= ix * invM[j]\n      vy[j] -= iy * invM[j]\n    }\n  }\n}\n\n/////////////////////\n// PARTICLES (explode glitch)\n/////////////////////\n\nfunction spawnBurst() {\n  // pick random center\n  cx = floor(random(A))\n  cy = floor(random(W))\n  baseHue = random(1)\n\n  for (p = 0; p < PARTICLE_COUNT; p++) {\n    pxp[p] = cx + random(1) * 0.8\n    pyp[p] = cy + random(1) * 0.8\n    ang = random(1) * PI2\n    sp  = randRange(6.0, 11.0)\n    pvr[p] = cos(ang) * sp\n    pvt[p] = sin(ang) * sp\n    ptt[p] = PARTICLE_TTL * randRange(0.7, 1.0)\n    phu[p] = wrap01(baseHue + random(1) * 0.25)\n  }\n  pActive = 1\n}\n\nfunction updateParticles(dt) {\n  if (!pActive) return\n  alive = 0\n\n  for (p = 0; p < PARTICLE_COUNT; p++) {\n    if (ptt[p] > 0) {\n      ptt[p] -= dt\n      if (ptt[p] > 0) {\n        // integrate; wrap X, bounce Y\n        pxp[p] = wrapA(pxp[p] + pvr[p] * dt)\n        pyp[p] += pvt[p] * dt\n\n        if (pyp[p] < 0) { pyp[p] = -pyp[p]; pvt[p] = -pvt[p] * 0.7 }\n        if (pyp[p] > (W - 1)) { pyp[p] = 2*(W - 1) - pyp[p]; pvt[p] = -pvt[p] * 0.7 }\n\n        // mild drag so it looks glitchy, not ballistic forever\n        pvr[p] *= 0.985\n        pvt[p] *= 0.985\n\n        alive = 1\n      }\n    }\n  }\n  pActive = alive\n}\n\nfunction particleAt(px, py) {\n  if (!pActive) { pVal = 0; pHue = 0; return }\n\n  best = 0\n  bestHue = 0\n\n  for (p = 0; p < PARTICLE_COUNT; p++) {\n    if (ptt[p] > 0) {\n      dx = wrapDxSigned(px, pxp[p])\n      dy = py - pyp[p]\n      d2 = dx*dx + dy*dy\n      // soft radial falloff\n      r2 = PARTICLE_RADIUS * PARTICLE_RADIUS\n      if (d2 < r2) {\n        a = 1 - (d2 / r2)\n        // fade with ttl\n        fade = ptt[p] / PARTICLE_TTL\n        v = a * fade\n        if (v > best) { best = v; bestHue = phu[p] }\n      }\n    }\n  }\n\n  pVal = best * PARTICLE_VAL\n  pHue = bestHue\n}\n\n/////////////////////\n// INIT\n/////////////////////\n\nfunction initIfNeeded() {\n  if (inited) return\n  inited = 1\n\n  // allocate trails once pixelCount known\n  if (!trailV) {\n    trailV = array(pixelCount)\n    trailH = array(pixelCount)\n    for (i = 0; i < pixelCount; i++) { trailV[i] = 0; trailH[i] = 0 }\n  }\n\n  // init boxes\n  for (i = 0; i < BOX_COUNT; i++) {\n    bs[i] = floor(randRange(SIZE_MIN, SIZE_MAX + 0.999))\n    m[i] = randRange(MASS_MIN, MASS_MAX)\n    invM[i] = 1 / m[i]\n\n    // spread them around; keep within vertical range\n    ax[i] = wrapA((A / BOX_COUNT) * i + random(1) * 0.5)\n    hy[i] = randRange(0, (W - bs[i]) > 0 ? (W - bs[i]) : 0)\n\n    ang = (i / BOX_COUNT) * PI2\n    vx[i] = cos(ang) * TARGET_SPEED\n    vy[i] = sin(ang) * TARGET_SPEED\n    keepSpeed(i)\n\n    bh[i] = i / BOX_COUNT\n  }\n}\n\n/////////////////////\n// BEFORE RENDER\n/////////////////////\n\nexport function beforeRender(delta) {\n  initIfNeeded()\n\n  dt = min(delta / 1000, 0.05)\n\n  // maybe trigger a burst\n  if (random(1) < (EXPLODE_RATE * dt)) spawnBurst()\n  updateParticles(dt)\n\n  // integrate boxes\n  for (i = 0; i < BOX_COUNT; i++) {\n    ax[i] = wrapA(ax[i] + vx[i] * dt)\n    hy[i] += vy[i] * dt\n    clampY(i)\n  }\n\n  // collisions\n  for (k = 0; k < SOLVER_ITERS; k++) {\n    for (i = 0; i < BOX_COUNT; i++) {\n      for (j = i + 1; j < BOX_COUNT; j++) {\n        collide(i, j)\n      }\n    }\n  }\n\n  // enforce constant speed (prevents slowdown)\n  for (i = 0; i < BOX_COUNT; i++) keepSpeed(i)\n\n  // base hues\n  t = time(HUE_RATE_SEC / 65.536)\n  for (i = 0; i < BOX_COUNT; i++) {\n    bh[i] = wrap01(t + i / BOX_COUNT)\n  }\n\n  // glitch + tear frames\n  gFrame = floor(time(18 / 65.536) * 1000)\n  tearFrame = floor(time((1 / TEAR_FPS) / 65.536) * 100000)\n\n  // 3 tear bands\n  r0 = hash01(tearFrame * 31.0 + 1.0)\n  r1 = hash01(tearFrame * 37.0 + 2.0)\n  r2 = hash01(tearFrame * 41.0 + 3.0)\n\n  tearRow0 = floor(hash01(tearFrame * 53.0 + 4.0) * W)\n  tearRow1 = floor(hash01(tearFrame * 59.0 + 5.0) * W)\n  tearRow2 = floor(hash01(tearFrame * 61.0 + 6.0) * W)\n\n  tearShift0 = floor((hash01(tearFrame * 67.0 + 7.0) * 2 - 1) * TEAR_MAX_SHIFT)\n  tearShift1 = floor((hash01(tearFrame * 71.0 + 8.0) * 2 - 1) * TEAR_MAX_SHIFT)\n  tearShift2 = floor((hash01(tearFrame * 73.0 + 9.0) * 2 - 1) * TEAR_MAX_SHIFT)\n\n  tearOn0 = (r0 < TEAR_CHANCE) ? 1 : 0\n  tearOn1 = (r1 < TEAR_CHANCE) ? 1 : 0\n  tearOn2 = (r2 < TEAR_CHANCE) ? 1 : 0\n\n  tearHue0 = hash01(tearFrame * 79.0 + 10.0)\n  tearHue1 = hash01(tearFrame * 83.0 + 11.0)\n  tearHue2 = hash01(tearFrame * 89.0 + 12.0)\n}\n\n/////////////////////\n// RENDER\n/////////////////////\n\nexport function render2D(index, x, y) {\n  // mapper-derived coords (your zigzag):\n  around = floor(index / W)     // 0..31\n  h = index % W                 // 0..7\n  if (around % 2 == 1) h = (W - 1) - h\n\n  pxBase = around + 0.5\n  py = h + 0.5\n\n  // tearing shifts the sampling px (illusion)\n  px = pxBase\n  tearShift = 0\n  tearHue = 0\n  tearOn = 0\n\n  if (tearOn0 && h == tearRow0) { tearShift = tearShift0; tearHue = tearHue0; tearOn = 1 }\n  if (tearOn1 && h == tearRow1) { tearShift = tearShift1; tearHue = tearHue1; tearOn = 1 }\n  if (tearOn2 && h == tearRow2) { tearShift = tearShift2; tearHue = tearHue2; tearOn = 1 }\n\n  if (tearOn) px = wrapA(px + tearShift)\n\n  // boxes (dominant hue, additive value)\n  bestV = 0\n  hue = 0\n  total = 0\n\n  for (i = 0; i < BOX_COUNT; i++) {\n    v = softBox(px, py, i)\n    total += v\n    if (v > bestV) {\n      bestV = v\n      hue = radialHue(px, py, i, bh[i])\n    }\n  }\n\n  // particles (explode bursts)\n  particleAt(px, py) // sets pVal, pHue\n\n  // background sparkles\n  r = hash01(index + gFrame * 97.0)\n  sparkle = (r < GLITCH_RATE) ? 1 : 0\n  gAmt = sparkle ? GLITCH_VAL : 0\n  gHue = hash01(index * 3.0 + gFrame * 19.0)\n\n  // choose output before trails\n  outV = 0\n  outH = 0\n\n  if (total > 0) {\n    outH = hue\n    outV = clamp(total + (tearOn ? TEAR_VAL * 0.15 : 0) + pVal * 0.65, 0, 1)\n  } else if (pVal > 0) {\n    outH = pHue\n    outV = clamp(pVal, 0, 1)\n  } else if (tearOn) {\n    outH = tearHue\n    outV = TEAR_VAL\n  } else if (gAmt > 0) {\n    outH = gHue\n    outV = gAmt\n  } else {\n    outH = 0\n    outV = 0\n  }\n\n  // TRAILS: max-hold with decay; keep hue of the brighter contributor\n  prevV = trailV[index]\n  holdV = prevV * TRAIL_DECAY\n\n  if (outV >= holdV) {\n    trailV[index] = outV\n    trailH[index] = outH\n    hsv(outH, 1, outV)\n  } else {\n    trailV[index] = holdV\n    hsv(trailH[index], 1, holdV)\n  }\n}\n\nexport function render(index) {\n  hsv(0, 0, 0)\n}\n"
  },
  "preview": "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"
}